# B-Tree 스터디 노트

= 2025 11 29 =
오늘 배운 것:
- B-Tree의 기본 구조와 최소 차수 `t`의 의미
- B-Tree의 검색 및 삽입 동작 원리
- 노드가 꽉 찼을 때 중간 키를 부모로 올리는 **분할(Split)** 과정
- 왜 B-Tree가 디스크 기반 스토리지에 효율적인가

소감문: B+ Tree를 먼저 보고 B-Tree를 보니 두 자료구조의 차이점이 확 와닿는다. 

B+ Tree가 모든 데이터를 리프에만 저장하는 것과 달리, B-Tree는 내부 노드에도 데이터를 저장할 수 있다는 게 가장 큰 차이점인 것 같다.

`insert` 로직을 따라가면서 `splitChild`가 어떻게 동작하는지 보는 게 정말 어려웠다. 특히 삽입 과정에서 부모로 내려가기 전에 미리 자식 노드가 꽉 찼는지 검사하고, 꽉 찼으면 **미리 분할**해버리는 방식이 인상 깊었다. 

이렇게 해야 부모 노드로 다시 올라오는 복잡한 과정(backtracking)이 필요 없어진다는 걸 깨달았다. `BTree(3)`을 기준으로 손으로 직접 그려보면서 코드를 따라가니 얼핏 읽히는 것 같기도 하다. 책 제목은 쉽게 푸는 자료구조라는데 전혀 아닌듯; 어렵다. 

참고로 `-` 는 minus 가 아니라 dash 를 의미한다. 헷갈림.

---

## 1. B-Tree, 너 왜 쓰는 거니?

B-Tree는 B+ Tree의 원형이 되는 자료구조로, 스스로 균형을 맞추는 트리(Self-balancing tree)다. 

B-Tree 역시 **대용량 데이터를 디스크에 저장하고 효율적으로 탐색**하기 위해 설계되었다. 

트리 구조가 항상 넓고 낮게 유지되도록 설계되어 디스크 I/O 횟수를 최소화하는 것이 핵심 목표다.

내가 이해한 B-Tree의 핵심 특징은 이렇다.

-   **데이터가 모든 노드에 저장될 수 있다.**
    -   B+ Tree와 달리, B-Tree는 내부 노드(Internal Node)와 리프 노드(Leaf Node) 모두 `(키, 데이터)` 쌍을 저장할 수 있다. (이 예제 코드에서는 key만 저장하지만, 실제로는 key에 매핑된 데이터 포인터가 함께 저장된다.)
-   **모든 리프 노드는 같은 높이에 있다 (Balanced).**
    -   이 특징 덕분에 어떤 키를 검색하든 항상 비슷한 탐색 시간을 보장한다. 최악의 경우에도 예측 가능한 성능을 제공한다.
-   **하나의 노드에 많은 자식을 가질 수 있다.**
    -   노드 하나에 많은 키와 자식 포인터를 저장함으로써 트리 전체의 높이를 낮게 유지한다. 높이가 낮다는 것은 루트에서 특정 데이터까지 도달하는 경로가 짧다는 뜻이고, 이는 곧 디스크 접근 횟수가 줄어듦을 의미한다.

## 2. B-Tree 구조 파헤치기

B-Tree의 모든 노드는 기본적으로 동일한 구조를 가지며, `leaf`라는 boolean 값으로 리프 노드인지 내부 노드인지를 구분한다.

### 최소 차수 `t` (Minimum Degree)

B-Tree를 이해하는 가장 중요한 개념은 바로 최소 차수 `t`이다. `t`는 B-Tree의 구조를 결정하는 규칙의 기준이 된다. (단, 루트 노드는 예외)

-   **키의 개수**: 노드 하나는 최소 `t-1`개, 최대 `2t-1`개의 키를 가질 수 있다.
-   **자식 노드의 수**: 내부 노드는 최소 `t`개, 최대 `2t`개의 자식 포인터를 가질 수 있다.

`t`가 클수록 노드 하나에 더 많은 데이터를 담을 수 있어 트리의 높이가 낮아지고, 디스크 I/O 성능이 향상된다.

## 3. 핵심 동작 원리: 삽입(Insert)과 분할(Split)

검색은 루트부터 키를 비교하며 올바른 자식 노드로 내려가는 과정을 반복하면 되므로 비교적 간단하다. B-Tree의 진정한 핵심은 **삽입**과 **분할** 과정에 있다.

1.  **삽입할 위치를 찾아 내려간다.**
2.  단, 그냥 내려가는 게 아니라 **내려가는 경로에 꽉 찬 노드(`2t-1`개의 키를 가진 노드)가 있는지 확인**한다.
3.  만약 꽉 찬 노드를 만나면, 그 노드로 내려가기 전에 **미리 분할(Split)을 수행**한다.
    -   이 "미리 분할하는" 전략 덕분에, 삽입이 끝난 후 다시 트리 위로 올라가면서 구조를 조정할 필요가 없어진다.
4.  적절한 리프 노드에 도달하면, 키를 정렬 순서에 맞게 삽입한다.

### 분할 (Split) 과정

꽉 찬 노드 `y` (키 `2t-1`개)를 분할하는 과정은 다음과 같다.

1.  가운데 위치한 `t-1`번째 키를 기준으로 노드를 나눈다.
2.  이 가운데 키는 부모 노드 `x`로 '이동'(Move-up)**하며, 분할된 자식 노드에는 더 이상 존재하지 않는다. 즉, 자신을 희생하여 두 노드를 나누는 기준점이 되는 셈이다.
3.  가운데 키의 왼쪽 `t-1`개의 키들은 기존 노드 `y`에 그대로 남는다.
4.  가운데 키의 오른쪽 `t-1`개의 키들은 새로운 노드 `z`를 만들어 저장한다.
5.  새로 만들어진 노드 `z`는 부모 노드 `x`의 새로운 자식이 된다 (원래 노드 `y` 바로 옆에 위치).

만약 루트 노드가 꽉 차서 분할되는 경우, 새로운 루트가 생성되고 트리의 높이가 1 증가한다. 이것이 B-Tree가 스스로 성장하며 균형을 맞춰나가는 방식이다.

## 4. Java 코드로 컴파일하고 실행하기

이 프로젝트의 B-Tree 코드를 돌려보려면 컴파일과 실행, 두 단계가 필요하다.

### 1. B-Tree 파일 컴파일

`javac`는 `.java` 소스 코드를 JVM이 이해하는 `.class` 바이트코드로 바꾸는 컴파일러다. 프로젝트 루트 폴더(`csapp-code`)에서 아래 명령어를 실행하면 `BTree` 패키지 안의 모든 자바 파일이 컴파일된다.

```bash
javac java-datastructures/BTree/*.java
```

### 2. 데모 프로그램 실행

컴파일이 끝났으면 `java` 명령어로 `BTreeDemo`를 실행해볼 수 있다. 이때 `-cp`(classpath) 옵션으로 클래스 파일들이 어디서부터 시작하는지 알려줘야 한다. `java-datastructures`가 우리 패키지들의 루트 폴더 역할을 하므로, 다음과 같이 실행한다.

```bash
java -cp java-datastructures BTree.BTreeDemo
```

이렇게 하면 `BTreeDemo` 클래스의 `main` 메소드가 실행되면서, B-Tree에 데이터를 삽입하고 순회, 검색하는 결과를 눈으로 확인할 수 있다.
